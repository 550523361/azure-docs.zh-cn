---
title: 选择分布列 = 超缩放（Citus） - 用于后格雷SQL的 Azure 数据库
description: 了解如何在用于 PostgreSQL 的 Azure 数据库中选择常见超大规模方案中的分发列。
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: 8ced9767d81affceef851820ee587f4f3dd24deb
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/27/2020
ms.locfileid: "74975663"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus"></a>在 Azure 数据库中为 PostgreSQL 和超大规模（Citus）选择分发列

选择每个表的分布列是您将做出的最重要的建模决策之一。 用于 PostgreSQL 和超大规模 （Citus） 的 Azure 数据库根据行的分布列的值将行存储在分片中。

正确的选择将相关数据组合在同一物理节点上，这使得查询快速，并增加了对所有 SQL 功能的支持。 错误的选择使系统运行缓慢，并且不支持跨节点的所有 SQL 功能。

本文提供了两个最常见的超大规模 （Citus） 方案的分发列提示。

### <a name="multi-tenant-apps"></a>多租户应用

多租户体系结构使用分层数据库建模的形式在服务器组中的节点之间分发查询。 数据层次结构的顶部称为*租户 ID，* 需要存储在每个表上的列中。

超大规模 （Citus） 检查查询以查看它们涉及的租户 ID 并查找匹配的表分片。 它将查询路由到包含分片的单个辅助节点。 运行将所有相关数据放在同一节点上的查询称为主机代管。

下图说明了多租户数据模型中的主机代管。 它包含两个表，即"帐户"和"市场活动`account_id`"，每个表由 分发。 框框表示分片。 绿色分片一起存储在一个辅助节点上，蓝色分片存储在另一个辅助节点上。 请注意，当两个表都限制为同一帐户\_ID 时，帐户和市场活动之间的联接查询如何在一个节点上将所有必要的数据放在一起。

![多租户主机代管](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

要在您自己的架构中应用此设计，请确定应用程序中的租户构成内容。 常见实例包括公司、帐户、组织或客户。 列名称将类似于`company_id`或`customer_id`。 检查每个查询并问自己，如果包含其他 WHERE 子句以将涉及的所有表限制为具有相同租户 ID 的行，它是否有效？
多租户模型中的查询范围为租户。 例如，对销售或库存的查询在特定商店中限定范围。

#### <a name="best-practices"></a>最佳做法

-   **按公共租户\_ID 列对分布式表进行分区。** 例如，在租户为公司的 SaaS 应用程序中，租户\_ID 可能是公司\_ID。
-   **将小型交叉租户表转换为参考表。** 当多个租户共享一个小信息表时，将其分发为参考表。
-   **按租户\_ID 限制筛选所有应用程序查询。** 每个查询应一次请求一个租户的信息。

阅读[多租户教程](./tutorial-design-database-hyperscale-multi-tenant.md)，了解如何构建此类应用程序的示例。

### <a name="real-time-apps"></a>实时应用

多租户体系结构引入了分层结构，并使用数据主机代管来路由每个租户的查询。 相比之下，实时体系结构依赖于其数据的特定分布属性来实现高度并行处理。

我们使用"实体 ID"作为实时模型中分发列的术语。 典型的实体是用户、主机或设备。

实时查询通常询问按日期或类别分组的数字聚合。 Hyperscale （Citus） 将这些查询发送到每个分片，以取得部分结果，并在协调器节点上组装最终答案。 当尽可能多的节点贡献时，当没有单个节点必须执行不成比例的工作量时，查询运行速度最快。

#### <a name="best-practices"></a>最佳做法

-   **选择基数高的列作为分布列。** 为了进行比较，订单表中的值"新建、已付"和"已发货"的"状态"字段是分发列的糟糕选择。 它只假定这些数值，这限制了可以保存数据的分片数以及可以处理数据的节点数。 在基数高的列中，最好选择在分组子句中经常使用的列或作为联接键。
-   **选择分布均匀的列。** 如果在偏向到某些公共值的列上分布表，则表中的数据往往会在某些分片中累积。 保存这些分片的节点最终比其他节点执行更多的工作。
-   **在其公共列上分发事实和维度表。**
    事实表只能有一个分发密钥。 在另一个键上联接的表不会与事实表共存。 根据联接频率和联接行的大小选择一个维度以进行共定位。
-   **将某些维度表更改为参考表。** 如果维度表不能与事实数据表共存，则可以通过将维度表的副本以参考表的形式分发到所有节点来提高查询性能。

阅读[实时仪表板教程](./tutorial-design-database-hyperscale-realtime.md)，了解如何构建此类应用程序的示例。

### <a name="time-series-data"></a>时间序列数据

在时间序列工作负载中，应用程序在存档旧信息时查询最新信息。

在超量程 （Citus） 中建模时间序列信息的最常见错误是将时间戳本身用作分布列。 基于时间的哈希分布将时间似乎随机分布到不同的分片中，而不是将时间范围保持在分片中。 涉及时间的查询通常引用时间范围，例如，最新数据。 这种类型的哈希分发会导致网络开销。

#### <a name="best-practices"></a>最佳做法

-   **不要选择时间戳作为分发列。** 选择其他分布列。 在多租户应用中，使用租户 ID 或在实时应用中使用实体 ID。
-   **使用 PostgreSQL 表分区以进行时间。** 使用表分区将一个大型时间排序数据表分解为多个继承的表，每个表包含不同的时间范围。 在超大规模（Citus）中分发 Postgres 分区表会为继承的表创建分片。

阅读[时间序列教程](https://aka.ms/hyperscale-tutorial-timeseries)，了解如何构建此类应用程序的示例。

## <a name="next-steps"></a>后续步骤
- 了解分布式数据之间的[主机代管](concepts-hyperscale-colocation.md)如何帮助查询快速运行。
