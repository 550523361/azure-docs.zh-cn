---
title: 故障转移和修补-Azure Cache for Redis |Microsoft Docs
description: 了解用于 Redis 的 Azure 缓存的故障转移、修补和更新过程。
services: cache
author: asasine
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.author: adsasine
ms.openlocfilehash: 22c48441795e8aff9aba6540f15130452bcec2f7
ms.sourcegitcommit: ac56ef07d86328c40fed5b5792a6a02698926c2d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/08/2019
ms.locfileid: "73819176"
---
# <a name="failover-and-patching-for-azure-cache-for-redis"></a>适用于 Redis 的 Azure 缓存的故障转移和修补

若要构建复原和成功的客户端应用程序，了解 Azure Cache for Redis 服务的上下文中的故障转移非常重要。 故障转移可以是计划管理操作的一部分，也可能是由于计划外的硬件或网络故障引起的。 使用缓存故障转移的常见情况是，管理服务会修补适用于 Redis 二进制文件的 Azure 缓存。 本文介绍故障转移的定义、修补过程中的发生方式以及如何构建复原的客户端应用程序。

## <a name="what-is-a-failover"></a>什么是故障转移？

让我们从 Redis 的 Azure 缓存故障转移概述开始。

### <a name="a-quick-summary-of-cache-architecture"></a>缓存体系结构的快速摘要

缓存由多个具有单独专用 IP 地址的虚拟机构造。 每个虚拟机（也称为节点）都连接到具有单个虚拟 IP 地址的共享负载均衡器。 每个节点都运行 Redis 服务器进程，可通过主机名和 Redis 端口进行访问。 每个节点都被视为主节点或副本节点。 当客户端应用程序连接到缓存时，其流量会经历此负载均衡器，并自动路由到主节点。

在基本缓存中，单一节点始终为主节点。 在标准或高级缓存中，有两个节点：选择一个节点作为主节点，另一个节点为副本。 由于标准缓存和高级缓存具有多个节点，因此一个节点可能不可用，而另一个节点会继续处理请求。 群集缓存由许多分片组成，每个缓存具有不同的主节点和副本节点。 一分片可能会关闭，而其他人仍可使用。

> [!NOTE]
> 基本缓存没有多个节点，并且不提供服务级别协议（SLA）来实现可用性。 建议仅将基本缓存用于开发和测试目的。 为多节点部署使用标准或高级缓存，以提高可用性。

### <a name="explanation-of-a-failover"></a>故障转移的说明

发生故障转移时，副本节点会将其自身提升为主节点，而旧的主节点会关闭现有连接。 主节点重新启动后，它会注意到角色发生了变化，并使自身降级成为副本。 然后，它将连接到新的主服务器并同步数据。 故障转移可以是计划的或非计划的。

*计划的故障转移*发生在系统更新过程中（例如 Redis 修补或 OS 升级）和管理操作（例如缩放和重启）。 由于节点会提前通知更新，因此它们可以以协作方式交换角色并快速更新更改的负载均衡器。 计划的故障转移通常在1秒内完成。

发生非*计划的故障转移*可能是由于硬件故障、网络故障或主节点的其他意外中断造成的。 副本节点会将其自身提升为 master，但该过程需要更长时间。 副本节点必须首先检测其主节点是否不可用，然后才能启动故障转移过程。 副本节点还必须验证这种计划外故障不是暂时性的还是本地的，以避免不必要的故障转移。 此检测延迟意味着计划外故障转移通常在10到15秒内完成。

## <a name="how-does-patching-occur"></a>如何进行修补？

Azure Cache for Redis 服务会定期更新缓存，并提供最新的平台功能和修补程序。 若要修补缓存，该服务应遵循以下步骤：

1. 管理服务选择一个要修补的节点。
1. 如果所选节点是主节点，则相应的副本节点会以协作方式提升自身。 此升级被视为计划的故障转移。
1. 所选节点将重新启动以获取新更改，并将备份为副本节点。
1. 副本节点连接到主节点并同步数据。
1. 数据同步完成后，剩余节点的修补过程将重复。

由于修补是计划的故障转移，因此副本节点会快速地将自身提升为主节点并开始处理请求和新连接。 基本缓存没有副本节点，并且在更新完成前不可用。 群集缓存的每个分片都单独进行修补，且不会关闭与另一个分片的连接。

> [!IMPORTANT]
> 每次修补一个节点以防止数据丢失。 基本缓存将会丢失数据。 群集缓存一次修补一个分片。

同一资源组和区域中的多个缓存一次也进行修补。  位于不同资源组或不同区域的缓存可以同时进行修补。

由于完全数据同步发生在进程重复之前发生，因此当你使用标准或高级缓存时不太可能发生数据丢失。 您可以通过[导出](cache-how-to-import-export-data.md#export)数据和启用[持久性](cache-how-to-premium-persistence.md)来防止数据丢失。

## <a name="additional-cache-load"></a>额外的缓存负载

发生故障转移时，标准和高级缓存需要将数据从一个节点复制到另一个节点。 此复制会导致服务器内存和 CPU 的负载增加。 如果缓存实例已经过大负载，则客户端应用程序可能会遇到较高的延迟。 在极端情况下，客户端应用程序可能会收到超时异常。 若要帮助减轻此额外负载的影响，请[配置](cache-configure.md#memory-policies)缓存的 `maxmemory-reserved` 设置。

## <a name="how-does-a-failover-affect-my-client-application"></a>故障转移如何影响我的客户端应用程序？

客户端应用程序显示的错误数取决于故障转移时该连接上挂起的操作的数量。 通过关闭其连接的节点路由的任何连接将会出现错误。 许多客户端库会在连接中断时引发不同类型的错误，包括超时异常、连接异常或套接字异常。 异常的数量和类型取决于当缓存关闭其连接时，请求在代码路径中的位置。 例如，当发生故障转移时，发送请求但未收到响应的操作可能会收到超时异常。 关闭的连接对象上的新请求会收到连接异常，直到重新连接成功为止。

大多数客户端库会尝试重新连接到缓存（如果配置为这样做）。 但是，出现意外错误可能会将库对象置于不可恢复的状态。 如果错误的保留时间超过了预先配置的时间，则应重新创建连接对象。 在 Microsoft.NET 和其他面向对象的语言中，无需重新启动应用程序\<即可重新创建连接， [\> 模式](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#reconnecting-with-lazyt-pattern)。

### <a name="how-do-i-make-my-application-resilient"></a>如何实现使应用程序具有复原能力？

由于不能完全避免故障转移，因此请编写客户端应用程序，以复原连接中断和失败的请求。 虽然大多数客户端库会自动重新连接到缓存终结点，但很少有它们会尝试重试失败的请求。 根据应用程序方案，使用重试逻辑和回退可能有意义。

若要测试客户端应用程序的复原能力，请使用[重新启动](cache-administration.md#reboot)作为连接中断的手动触发器。 此外，我们建议你在缓存上[计划更新](cache-administration.md#schedule-updates)。 告诉管理服务在指定的每周时段内应用 Redis 运行时修补程序。 通常情况下，当客户端应用程序流量较低时，通常会发生这种情况。

### <a name="client-network-configuration-changes"></a>客户端网络配置更改

某些客户端网络配置更改可能会触发 "无可用连接" 错误。 此类更改可能包括：

- 在过渡和生产槽之间交换客户端应用程序的虚拟 IP 地址。
- 缩放应用程序实例的大小或数量。

此类更改可能会导致连接问题持续不到一分钟。 除了 Azure Cache for Redis 服务外，客户端应用程序可能会失去与其他外部网络资源的连接。

## <a name="next-steps"></a>后续步骤

- [计划缓存更新](cache-administration.md#schedule-updates)。
- 使用[重启](cache-administration.md#reboot)测试应用程序复原能力。
- [配置](cache-configure.md#memory-policies)内存预留和策略。
