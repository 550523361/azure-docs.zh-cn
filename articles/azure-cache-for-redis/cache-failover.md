---
title: 故障转移和修补-Azure Cache for Redis |Microsoft Docs
description: 了解用于 Redis 的 Azure 缓存的故障转移、修补和更新过程。
services: cache
author: asasine
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.author: adsasine
ms.openlocfilehash: 305511efe86d2b241ef5014d9c3f0501cfd3fbdc
ms.sourcegitcommit: 9a4296c56beca63430fcc8f92e453b2ab068cc62
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/20/2019
ms.locfileid: "72675897"
---
# <a name="failover-and-patching-for-azure-cache-for-redis"></a>适用于 Redis 的 Azure 缓存的故障转移和修补

了解使用 Azure Cache for Redis 服务进行的故障转移对于构建可复原且成功的客户端应用程序至关重要。 缓存故障转移的一个常见原因是管理服务修补 Redis 二进制文件。 本文介绍故障转移的定义，以及如何在修补过程中进行故障转移，以及如何构建复原的客户端应用程序。

## <a name="what-is-a-failover"></a>什么是故障转移？

### <a name="a-quick-summary-of-our-architecture"></a>体系结构的快速摘要

缓存由多个具有不同专用 Ip 的虚拟机构造。 每个虚拟机（也称为节点）都连接到具有单个虚拟 IP 的共享负载均衡器。 每个节点都运行 Redis 服务器进程，可通过主机名和 Redis 端口进行访问。 每个节点均被视为主节点或副本节点。 当客户端应用程序连接到缓存时，其流量会经历此负载均衡器，并自动路由到主节点。

在基本缓存中，单一节点始终为主节点。 在标准或高级缓存中，有两个节点选择了 master，另一个节点为副本。 由于标准缓存和高级缓存具有多个节点，因此一个节点可能不可用，而另一个节点会继续处理请求。 群集缓存由许多分片组成，每个缓存具有不同的主节点和副本节点。 一分片可能会关闭，而其他人仍可使用。

> [!NOTE]
> 基本缓存没有多个节点，并且没有提供对可用性的 SLA。 基本缓存仅建议用于开发和测试目的。 为多节点部署使用标准或高级缓存，以提高可用性。

### <a name="a-failover-explained"></a>故障转移说明

发生故障转移时，副本节点会将其自身提升为主节点，而旧的主节点会关闭现有连接。 主节点重新启动后，它会注意到角色发生了变化，并使自身降级成为副本。 然后，它将连接到新的 master 并同步数据。 故障转移可以是计划的或非计划的。

计划的故障转移发生在系统更新过程中，例如，Redis 修补或 OS 升级和管理操作（例如缩放和重启）。 由于向节点提供了更新的高级通知，因此它们可以以协作方式交换角色并快速更新更改的负载均衡器。 计划的故障转移应在1秒内完成。

发生非计划的故障转移可能是由于硬件故障、网络故障或主节点的其他意外中断造成的。 副本节点会将其自身提升为 master，但该过程需要更长时间。 副本节点必须首先检测其主节点不可用，然后才能启动故障转移过程。 副本节点还必须验证此计划外故障是不是暂时性的还是本地的，以避免 overeager 故障转移。 此检测延迟意味着计划外故障转移通常在10到15秒内完成。

## <a name="how-does-patching-occur"></a>如何进行修补？

Azure Cache for Redis 服务会定期维护，以利用最新的平台功能和修补程序来更新缓存。 若要修补缓存，该服务应遵循以下步骤：

1. 管理服务选择一个要修补的节点。
1. 如果所选节点是主节点，其副本节点会以协作方式提升自身。 此升级被视为计划的故障转移。
1. 所选节点将重新启动以获取新更改，并将备份为副本节点。 副本节点连接到主节点并同步数据。
1. 数据同步完成后，剩余节点会重复修补过程。

由于修补是计划的故障转移，因此副本节点会快速地将自身提升为主节点并开始处理请求和新连接。 基本缓存没有副本节点，并且在更新完成前不可用。 群集缓存的每个分片都单独进行修补，且不会关闭与另一个分片的连接。

> [!IMPORTANT]
> 每次修补一个节点以防止数据丢失。 基本缓存将会丢失数据。 群集缓存一次修补一个分片。

同一资源组和区域中的多个缓存一次也进行修补。  位于不同资源组或不同区域的缓存可以同时进行修补。

由于完全数据同步发生在进程重复之前，因此使用标准或高级缓存时不太可能发生数据丢失。 使用[导出](cache-how-to-import-export-data.md#export)数据并启用[持久性](cache-how-to-premium-persistence.md)，可以进一步防止数据丢失。

### <a name="additional-cache-load"></a>额外的缓存负载

发生故障转移时，标准和高级缓存需要将数据从一个节点复制到另一个节点。 此复制会导致服务器内存和 CPU 的负载增加。 如果缓存实例已经过大负载，则客户端应用程序可能会遇到较高的延迟。 在极端情况下，客户端应用程序可能会收到超时异常。 [配置](cache-configure.md#memory-policies)缓存的 `maxmemory-reserved` 设置，以帮助减轻此额外负载的影响。

## <a name="how-does-a-failover-impact-my-client-application"></a>故障转移如何影响我的客户端应用程序？

客户端应用程序显示的错误数将取决于故障转移时该连接上挂起的操作的数目。 通过节点关闭的连接将会出现错误。 许多客户端库可能会引发不同类型的错误，包括连接中断时的超时异常、连接异常或套接字异常。 异常的数量和类型取决于当缓存关闭其连接时，请求在代码路径中的位置。 例如，在发生故障转移时，发送请求但未收到响应的操作可能会出现超时异常。 关闭的连接对象上的新请求将接收连接异常，直到重新连接成功为止。

大多数客户端库将尝试重新连接到缓存（如果配置为执行此操作），但未预料的 bug 偶尔可能会将库对象置于不可恢复的状态。 如果错误的保留时间超过了预先配置的时间，则应重新创建连接对象。 在 .NET 和其他面向对象的语言中，在不重新启动应用程序的情况下重新创建连接可以使用[懒惰 \<T \> 模式](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#reconnecting-with-lazyt-pattern)来完成。

### <a name="what-should-i-do-in-my-application"></a>我应该在我的应用程序中执行哪些操作？

由于无法完全避免故障转移，因此应编写客户端应用程序以使连接中断和失败请求复原。 尽管大多数客户端库会自动重新连接到缓存终结点，但很少有客户端库会尝试重试失败的请求。 根据应用程序方案的不同，重试逻辑可能有意义。

若要测试客户端应用程序的复原能力，请使用[重新启动](cache-administration.md#reboot)作为连接中断的手动触发器。 此外，建议在缓存上[计划更新](cache-administration.md#schedule-updates)，让管理服务在指定的每周时段内应用 Redis 运行时修补程序。 通常，在客户端应用程序流量降低时选择这些窗口以避免潜在的事件。

### <a name="client-network-configuration-changes"></a>客户端网络配置更改

某些客户端网络配置更改可能会触发 "无可用连接" 错误。  在暂存和生产槽之间交换客户端应用程序的虚拟 IP 地址，或者缩放应用程序实例的大小/数量可能会导致最近不到一分钟的连接问题。 除 Redis 外，客户端应用程序可能会失去与其他外部网络资源的连接。

## <a name="next-steps"></a>后续步骤

- [计划缓存更新](cache-administration.md#schedule-updates)。
- 使用[重启](cache-administration.md#reboot)测试应用程序复原能力。
- [配置](cache-configure.md#memory-policies)内存预留和策略。
