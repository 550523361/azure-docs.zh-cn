---
title: 跨多个实例平衡分区负载-Azure 事件中心 |Microsoft Docs
description: 介绍如何使用事件处理器和 Azure 事件中心 SDK 来平衡应用程序的多个实例之间的分区负载。
services: event-hubs
documentationcenter: .net
author: ShubhaVijayasarathy
editor: ''
ms.service: event-hubs
ms.devlang: na
ms.topic: conceptual
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 01/16/2020
ms.author: shvija
ms.openlocfilehash: 1244fe64d0c23782fdae7a0f92415bada4bef55a
ms.sourcegitcommit: 67e9f4cc16f2cc6d8de99239b56cb87f3e9bff41
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/31/2020
ms.locfileid: "76907651"
---
# <a name="balance-partition-load-across-multiple-instances-of-your-application"></a>在应用程序的多个实例之间平衡分区负载
若要缩放事件处理应用程序，可以运行应用程序的多个实例，并让它在自身之间平衡负载。 在较旧的版本中， [EventProcessorHost](event-hubs-event-processor-host.md)允许在收到时平衡程序的多个实例和检查点事件之间的负载。 在较新版本（从5.0 开始）中， **EventProcessorClient** （.Net 和 Java）或**EventHubConsumerClient** （Python 和 JavaScript）允许您执行相同操作。 使用事件使开发模型变得更简单。 通过注册事件处理程序，订阅你感兴趣的事件。

本文介绍了使用多个实例从事件中心读取事件的示例方案，并提供了有关事件处理程序客户端功能的详细信息，使您可以一次接收来自多个分区的事件，并与其他的负载平衡使用相同事件中心和使用者组的使用者。

> [!NOTE]
> 用于事件中心缩放的关键在于分区使用者的理念。 与[竞争性使用者](https://msdn.microsoft.com/library/dn568101.aspx)模式相比，分区使用者模式通过消除争用瓶颈并简化端到端并行度来实现高缩放性。

## <a name="example-scenario"></a>示例方案

作为示例方案，请考虑监视 100000 home 的家庭安全公司。 它每隔一分钟就会从不同的传感器（如运动探测器、门/窗口打开传感器、玻璃中断探测器等）中获取数据，并将其安装在每个主文件夹中。 公司为居民提供了一个网站，用于以近乎实时的速度监视其主活动。

每个传感器将数据推送到事件中心。 事件中心配置了16个分区。 在使用时，您需要一种机制来读取这些事件，将这些事件合并（筛选器、聚合等），并将聚合转储到存储 blob，然后将该聚合投影到一个用户友好的网页中。

## <a name="write-the-consumer-application"></a>编写使用者应用程序

在分布式环境中设计使用者时，该方案必须处理下列要求：

1. **规模：** 创建多个使用者，每个使用者都从少数事件中心分区取得读取的所有权。
2. **负载平衡：** 动态增加或减少使用者。 例如，将新传感器类型（例如，碳 monoxide 检测器）添加到每个主页时，事件数会增加。 在这种情况下，操作员（人）会增加使用者实例数。 然后，使用者池可以重新平衡其拥有的分区数，以便与新添加的使用者共享负载。
3. **失败时无缝恢复：** 如果使用者（**使用者 a**）失败（例如，托管使用者的虚拟机突然崩溃），则其他使用者可以选取**使用者 a 的**分区，并继续。 此外，继续点（称为 "*检查点*" 或 "*偏移量*"）应位于失败的**使用者**的确切位置，或略微早于该位置。
4. **使用事件：** 虽然前面的三个要点涉及到使用者的管理，但必须存在使用这些事件的代码，并对其执行一些有用的操作。 例如，对其进行聚合并将其上传到 blob 存储。

## <a name="event-processor-or-consumer-client"></a>事件处理器或使用者客户端

不需要构建自己的解决方案来满足这些要求。 Azure 事件中心 Sdk 提供此功能。 在 .NET 或 Java Sdk 中，使用事件处理程序客户端（EventProcessorClient），在 Python 和 Java 脚本 Sdk 中使用 EventHubConsumerClient。 在旧版本的 SDK 中，这是支持这些功能的事件处理器主机（EventProcessorHost）。

对于大多数生产方案，建议使用事件处理程序客户端来读取和处理事件。 处理器客户端旨在提供强大的体验来处理事件中心的所有分区中的事件，同时提供一种功能强大的容错方法，同时提供检查其进度的方法。 在给定事件中心的使用者组的上下文中，事件处理器客户端也能够以协作方式工作。 当实例变为可用或组不可用时，客户端将自动管理工作的分发和平衡。

## <a name="partition-ownership-tracking"></a>分区所有权跟踪

事件处理器实例通常拥有一个或多个分区中的事件并对其进行处理。 分区的所有权在与事件中心和使用者组组合关联的所有活动事件处理器实例中均匀分布。 

每个事件处理器都为其提供唯一标识符，并通过在检查点存储中添加或更新条目来声明分区的所有权。 所有事件处理程序实例会定期与此存储进行通信，以更新其自己的处理状态，并了解其他活动实例。 然后，将使用此数据来平衡活动处理器之间的负载。 新实例可以加入处理池以进行扩展。 当实例发生故障时，无论是故障还是缩减，分区所有权都将正常传输到其他活动处理器。

检查点存储中的分区所有权记录将跟踪事件中心命名空间、事件中心名称、使用者组、事件处理器标识符（也称为所有者）、分区 id 和上次修改时间。



| 事件中心命名空间               | 事件中心名称 | **使用者组** | Owner                                | 分区 ID | 上次修改时间  |
| ---------------------------------- | -------------- | :----------------- | :----------------------------------- | :----------- | :------------------ |
| mynamespace.servicebus.windows.net | myeventhub     | myconsumergroup    | 3be3f9d3-9d9e-4c50-9491-85ece8334ff6 | 0            | 2020-01-15T01：22：15 |
| mynamespace.servicebus.windows.net | myeventhub     | myconsumergroup    | f5cc5176-ce96-4bb4-bbaa-a0e3a9054ecf | 1            | 2020-01-15T01：22：17 |
| mynamespace.servicebus.windows.net | myeventhub     | myconsumergroup    | 72b980e9-2efc-4ca7-ab1b-ffd7bece8472 | 2            | 2020-01-15T01：22：10 |
|                                    |                | ：                  |                                      |              |                     |
|                                    |                | ：                  |                                      |              |                     |
| mynamespace.servicebus.windows.net | myeventhub     | myconsumergroup    | 844bd8fb-1f3a-4580-984d-6324f9e208af | 15           | 2020-01-15T01：22：00 |

每个事件处理器实例获取分区的所有权，并从上一个已知的[检查点](# Checkpointing)开始处理该分区。 如果处理器出现故障（VM 关闭），则其他实例将通过查看上次修改时间来检测此情况。 其他实例将尝试获取之前由非活动实例拥有的分区的所有权，而检查点存储将保证只有其中一个实例成功地声明分区的所有权。 因此，在任何给定时间点，最多有一个从分区接收事件的处理器。

## <a name="receive-messages"></a>接收消息

创建事件处理器时，需要指定将处理事件和错误的函数。 对处理事件的函数的每个调用都将提供来自特定分区的单个事件。 你负责处理此事件。 如果要确保使用者至少处理一次每条消息，则需要使用重试逻辑编写自己的代码。 但请注意中毒消息。

建议你以相对较快的方式执行操作。 也就是说，尽量少处理。 如果需要写入存储并进行某些路由，最好使用两个使用者组，并提供两个事件处理器。

## <a name="checkpointing"></a>操作

*检查点*指的是事件处理器标记或提交上次成功处理的事件在分区中的位置的过程。 标记检查点通常在处理事件的函数中完成，并在使用者组中每个分区发生。 

如果事件处理程序与分区断开连接，则另一个实例可以继续处理该使用者组中该分区的最后一个处理器提交的检查点上的分区。 当处理器连接时，它会将偏移量传递给事件中心，以指定开始读取的位置。 通过这种方式，可以使用检查点将事件标记为 "已完成" （由下游应用程序 "完成"），并在事件处理器出现故障时提供复原能力。 可以通过指定此检查点过程的较小偏移量来返回到旧数据。 

当执行检查点以将事件标记为已处理时，将使用事件的偏移量和序列号添加或更新检查点存储中的条目。 用户应决定更新检查点的频率。 如果在每次成功处理事件后更新，事件会对基础检查点存储触发写入操作，从而导致性能和成本的影响。 另外，检查点每个事件的检查点都是一个排队消息模式，在该模式下，服务总线队列可能是比事件中心更好的选项。 事件中心背后的理念是，"至少一次" 的交付规模非常好。 通过使下游系统成为幂等，可以轻松地从故障或重启中恢复，导致多次接收相同的事件。

## <a name="thread-safety-and-processor-instances"></a>线程安全和处理器实例

默认情况下，事件处理程序或使用者是线程安全的，并且以同步方式进行。 当事件到达分区时，会调用用于处理事件的函数。 随后的消息和对此函数的调用会在后台继续运行，因为消息泵将继续在其他线程上的后台运行。 此线程安全消除了对线程安全集合的需求，并显著提高了性能。

## <a name="next-steps"></a>后续步骤
请参阅以下快速入门：

- [.NET Core](get-started-dotnet-standard-send-v2.md)
- [Java](event-hubs-java-get-started-send.md)
- [Python](get-started-python-send-v2.md)
- [JavaScript](get-started-node-send-v2.md)
