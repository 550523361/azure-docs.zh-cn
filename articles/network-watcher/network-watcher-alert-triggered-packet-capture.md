---
title: "在 Azure Functions 中使用警报和数据包捕获执行主动网络监视 | Microsoft Docs"
description: "本文介绍如何使用 Azure 网络观察程序创建警报触发的数据包捕获"
services: network-watcher
documentationcenter: na
author: georgewallace
manager: timlt
editor: 
ms.assetid: 75e6e7c4-b3ba-4173-8815-b00d7d824e11
ms.service: network-watcher
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: infrastructure-services
ms.date: 02/22/2017
ms.author: gwallace
translationtype: Human Translation
ms.sourcegitcommit: aaf97d26c982c1592230096588e0b0c3ee516a73
ms.openlocfilehash: 5fd017b6f7645220ee7572e50c02265de41e938c
ms.lasthandoff: 04/27/2017


---
# <a name="use-packet-capture-to-do-proactive-network-monitoring-with-alerts-and-azure-functions"></a>在 Azure Functions 中使用警报和数据包捕获执行主动网络监视

网络观察程序数据包捕获功能可以创建捕获会话来跟踪传入和传出虚拟机的流量。 可在捕获文件中包含一个定义的筛选器，以便只跟踪想要监视的流量。 然后，将此数据存储在存储 Blob 中或来宾计算机本地。

可以通过 Azure Functions 等其他自动化方案远程启动此功能。 数据包捕获提供基于定义的网络异常运行主动捕获的功能。 其他用途包括收集网络统计信息、获取网络入侵信息、调试客户端与服务器之间的通信，等等。

Azure 中部署的资源全天候运行， 但你或你的同事无法全天候主动监视所有资源的状态。 如果凌晨 2 点出现问题，会发生什么情况？

在 Azure 生态系统中使用网络观察程序、警报和 Functions，可以主动针对网络中的问题做出响应，并使用数据和工具来解决问题。

![方案][scenario]

## <a name="prerequisites"></a>先决条件

* 安装最新版本的 [Azure PowerShell](/powershell/azure/install-azurerm-ps)
* 准备好网络观察程序的现有实例，或者[创建网络观察程序的实例](network-watcher-create.md)。
* 在上述网络观察程序所在的同一区域中准备好一个装有 [Windows 扩展](../virtual-machines/windows/extensions-nwa.md)或 [Linux 虚拟机扩展](../virtual-machines/linux/extensions-nwa.md)的现有虚拟机。

## <a name="scenario"></a>方案

在本示例中，VM 发送的 TCP 段数超过平常，出现问题时你希望能够收到警报。 此处所示的 TCP 段只是用作示例，但你可以使用任何警报条件。

收到警报时，你希望获得数据包级别的数据来了解通信量为何提高。 这样，便可以采取措施让计算机恢复日常通信。

本方案假设已安装网络观察程序的现有实例，并且使用一个包含可用的有效虚拟机的资源组。

在本示例中，VM 发送的 TCP 段数超过平常，出现问题时你希望能够收到警报。 TCP 段只是用作示例，我们可以使用任何警报条件。 收到警报时，你希望获得数据包级别的数据来了解通信量为何提高，以便可以采取措施让计算机恢复日常通信。

以下列表了提供发生的工作流概述：

1. 在 VM 上触发警报。
1. 该警报通过 Webhook 调用 Azure 函数。
1. Azure 函数处理警报，并启动网络观察程序数据包捕获会话。
1. 数据包捕获在 VM 上运行并收集流量。
1. 将数据包捕获文件上载到存储帐户进行审查和诊断。

为了自动完成此过程，我们在 VM 上创建并连接了一个发生事件时要触发的警报，同时创建了一个用于调用网络观察程序的函数。

此方案执行以下任务：

* 创建一个启动数据包捕获的 Azure 函数。
* 在虚拟机上创建警报规则，并将警报规则配置为调用该 Azure 函数。

## <a name="creating-an-azure-function"></a>创建 Azure 函数

第一步是创建一个 Azure 函数来处理警报并创建数据包捕获。

1. 在 [Azure 门户](https://portal.azure.com)中，单击“新建” > “计算” > “Function App”

    ![创建 Function App][1-1]

2. 在“Function App”中输入以下值，然后单击“确定”创建 Function App：

    |**设置** | **值** | **详细信息** |
    |---|---|---|
    |**应用名称**|PacketCaptureExample|Function App 的名称|
    |**订阅**|[你的订阅]|选择要在其中创建 Function App 的订阅。||
    |**资源组**|PacketCaptureRG|为包含 Function App 的资源组命名。|
    |**托管计划**|使用计划| Function App 要使用的计划类型。 选项包括“使用计划”或“应用服务计划”。 |
    |**位置**|美国中部| 要在其中创建 Function App 的区域。|
    |**存储帐户**|{autogenerated}| 这是 Azure Functions 用作常规用途存储的存储帐户。|

3. 在 Function Apps 的“PacketCaptureExample”边栏选项卡上，单击“函数” > “自定义函数”下面的 **+**。 选择“HttpTrigger Powershell”，填写剩余的信息，然后单击“创建”以创建函数。

    |**设置** | **值** | **详细信息** |
    |---|---|---|
    |**方案**|试验|方案的类型|
    |**为函数命名**|AlertPacketCapturePowerShell|函数的名称|
    |**授权级别**|函数|函数的授权级别。|

![函数示例][functions1]

> [!NOTE]
> PowerShell 模板处于试验阶段且没有完全支持。

自定义项是此示例所必需的，并在以下步骤中说明：

### <a name="adding-modules"></a>添加模块

若要使用网络观察程序 PowerShell cmdlet，需要将最新 PowerShell 模块上传到 Function App。

1. 在已安装最新 Azure PowerShell 模块的本地计算机上，运行以下 PowerShell 命令：

    ```powershell
    (Get-Module AzureRM.Network).Path
    ```

    该示例提供 Azure PowerShell 模块的本地路径。 在稍后的步骤中将使用这些文件夹。 此方案中使用的模块包括：

    * AzureRM.Network

    * AzureRM.Profile

    * AzureRM.Resources

    ![powershell 文件夹][functions5]

1. 导航到“Function App 设置” > “转到应用服务编辑器”。

    ![函数 kudu][functions2]

1. 右键单击 AlertPacketCapturePowershell 文件夹，并创建一个名为 **azuremodules** 的文件夹。 继续为所需的每个模块创建子文件夹。

    ![函数 kudu][functions3]

    * AzureRM.Network

    * AzureRM.Profile

    * AzureRM.Resources

1. 右键单击 **AzureRM.Network** 子文件夹，然后单击“上传文件”。 导航到 Azure 模块的安装位置，在本地 AzureRM.Network 文件夹中选择该文件夹中的所有文件，然后单击“确定”。  对 AzureRM.Profile 和 AzureRM.Resources 重复这些步骤。

    ![上载文件][functions6]

1. 完成后，每个文件夹应具有来自本地计算机的 PowerShell 模块文件。

    ![powershell 文件][functions7]

### <a name="authentication"></a>身份验证

若要使用 PowerShell cmdlet，必须进行身份验证。 需要在 Function App 中配置身份验证。 若要配置身份验证，将配置环境变量，并需要将加密密钥文件上传到 Function App。

> [!NOTE]
> 此方案仅提供如何使用 Azure Functions 实现身份验证的一个示例，还可以通过其他方法来执行此操作。

#### <a name="encrypted-credentials"></a>加密凭据

以下 PowerShell 脚本创建了一个名为 **PassEncryptKey.key** 的密钥文件，并提供了所提供密码的加密版本。  此密码是为用于身份验证的 Azure AD 应用程序定义的同一密码。

```powershell
#variables
$keypath = "C:\temp\PassEncryptKey.key"
$AESKey = New-Object Byte[] 32
$Password = "<insert a password here>"

#keys
[Security.Cryptography.RNGCryptoServiceProvider]::Create().GetBytes($AESKey) 
Set-Content $keypath $AESKey

#get encrypted password
$secPw = ConvertTo-SecureString -AsPlainText $Password -Force
$AESKey = Get-content $KeyPath
$Encryptedpassword = $secPw | ConvertFrom-SecureString -Key $AESKey
$Encryptedpassword
```

在 Function App 的应用服务编辑器中，在 **AlertPacketCapturePowerShell** 下创建一个名为 **keys** 的文件夹，并上载前面的 PowerShell 示例所创建的 **PassEncryptKey.key** 文件。

![函数密钥][functions8]

### <a name="retrieve-values-for-environment-variables"></a>检索环境变量的值

最终必需的配置是设置访问用于身份验证的值所需的环境变量。 以下列表列出了创建的环境变量：

* AzureClientID

* AzureTenant

* AzureCredPassword


#### <a name="azureclientid"></a>AzureClientID

客户端 ID 是 Azure Active Directory 中应用程序的应用程序 ID。

1. 如果你还没有应用程序可使用，请运行以下示例以创建应用程序。

    ```powershell
    $app = New-AzureRmADApplication -DisplayName "ExampleAutomationAccount_MF" -HomePage "https://exampleapp.com" -IdentifierUris "https://exampleapp1.com/ExampleFunctionsAccount" -Password "<same password as defined earlier>"
    New-AzureRmADServicePrincipal -ApplicationId $app.ApplicationId
    Start-Sleep 15
    New-AzureRmRoleAssignment -RoleDefinitionName Contributor -ServicePrincipalName $app.ApplicationId
    ```

   > [!NOTE]
   > 创建应用程序时使用的密码应与先前在保存密钥文件时创建的密码相同。

1. 在 Azure 门户中，导航到“订阅”> 选择要使用的订阅 >“访问控制(IAM)”。

    ![函数 iam][functions9]

1. 选择要使用的帐户并单击“属性”。 复制应用程序 ID。

    ![函数应用程序 ID][functions10]

#### <a name="azuretenant"></a>AzureTenant

通过运行以下 PowerShell 示例获取租户 ID：

```powershell
(Get-AzureRmSubscription -SubscriptionName "<subscriptionName>").TenantId
```

#### <a name="azurecredpassword"></a>AzureCredPassword

AzureCredPassword 环境变量的值是通过运行以下 PowerShell 示例获得的值。 此示例是前面的**加密凭据**部分中显示的同一示例。 所需的值是 `$Encryptedpassword` 变量的输出。  这是我们使用 PowerShell 脚本加密的服务主体密码。

```powershell
#variables
$keypath = "C:\temp\PassEncryptKey.key"
$AESKey = New-Object Byte[] 32
$Password = "<insert a password here>"

#keys
[Security.Cryptography.RNGCryptoServiceProvider]::Create().GetBytes($AESKey) 
Set-Content $keypath $AESKey

#get encrypted password
$secPw = ConvertTo-SecureString -AsPlainText $Password -Force
$AESKey = Get-content $KeyPath
$Encryptedpassword = $secPw | ConvertFrom-SecureString -Key $AESKey
$Encryptedpassword
```

### <a name="store-the-environment-variables"></a>存储环境变量

1. 导航到 Function App，单击“Function App 设置” > “配置应用设置”

    ![配置应用设置][functions11]

1. 将环境变量及其值添加到应用设置并单击“保存”

    ![应用程序设置][functions12]

### <a name="add-powershell-to-the-function"></a>将 PowerShell 添加到函数

现在，可以从 Azure 函数内部调用网络观察程序。 根据要求，此函数的实现有所不同。 但是，代码的常规流程大致如下：

1. 处理输入参数
2. 查询现有的数据包捕获，验证限制并解决名称冲突
3. 使用适当的参数创建数据包捕获
4. 定期轮询数据包捕获，直到完成
5. 通知用户数据包捕获会话已完成

以下示例采用 PowerShell 语言，可在 Azure 函数中使用。 有需要为 subscriptionId、resourceGroupName 和 storageAccountName 替换的值。

```powershell
#Import Azure PowerShell modules required to make calls to Network Watcher
Import-Module "D:\home\site\wwwroot\AlertPacketCapturePowerShell\azuremodules\AzureRM.Profile\AzureRM.Profile.psd1" -Global
Import-Module "D:\home\site\wwwroot\AlertPacketCapturePowerShell\azuremodules\AzureRM.Network\AzureRM.Network.psd1" -Global
Import-Module "D:\home\site\wwwroot\AlertPacketCapturePowerShell\azuremodules\AzureRM.Resources\AzureRM.Resources.psd1" -Global

#Process Alert Request Body
$requestBody = Get-Content $req -Raw | ConvertFrom-Json

#Storage Account Id to save captures in
$storageaccountid = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{storageAccountName}"

#Packet Capture Vars
$packetcapturename = "PSAzureFunction"
$packetCaptureLimit = 10
$packetCaptureDuration = 10

#Credentials
$tenant = $env:AzureTenant
$pw = $env:AzureCredPassword
$clientid = $env:AzureClientId
$keypath = "D:\home\site\wwwroot\AlertPacketCapturePowerShell\keys\PassEncryptKey.key"

#Authentication
$secpassword = $pw | ConvertTo-SecureString -Key (Get-Content $keypath)
$credential = New-Object System.Management.Automation.PSCredential ($clientid, $secpassword)
Add-AzureRMAccount -ServicePrincipal -Tenant $tenant -Credential $credential #-WarningAction SilentlyContinue | out-null


#Get the VM that fired the Alert
if($requestBody.context.resourceType -eq "Microsoft.Compute/virtualMachines")
{
    Write-Output ("Subscription ID: {0}" -f $requestBody.context.subscriptionId)
    Write-Output ("Resource Group:  {0}" -f $requestBody.context.resourceGroupName)
    Write-Output ("Resource Name:  {0}" -f $requestBody.context.resourceName)
    Write-Output ("Resource Type:  {0}" -f $requestBody.context.resourceType)

    #Get the Network Watcher in the VM's Region
    $nw = Get-AzurermResource | Where {$_.ResourceType -eq "Microsoft.Network/networkWatchers" -and $_.Location -eq $requestBody.context.resourceRegion}
    $networkWatcher = Get-AzureRmNetworkWatcher -Name $nw.Name -ResourceGroupName $nw.ResourceGroupName

    #Get existing packetCaptures
    $packetCaptures = Get-AzureRmNetworkWatcherPacketCapture -NetworkWatcher $networkWatcher

    #Remove existing packet capture created by the function if it exists
    $packetCaptures | %{if($_.Name -eq $packetCaptureName)
    { 
        Remove-AzureRmNetworkWatcherPacketCapture -NetworkWatcher $networkWatcher -PacketCaptureName $packetCaptureName
    }}

    #Initiate Packet Capture on the VM that fired the alert
    if ((Get-AzureRmNetworkWatcherPacketCapture -NetworkWatcher $networkWatcher).Count -lt $packetCaptureLimit){
        echo "Initiating Packet Capture"
        New-AzureRmNetworkWatcherPacketCapture -NetworkWatcher $networkWatcher -TargetVirtualMachineId $requestBody.context.resourceId -PacketCaptureName $packetCaptureName -StorageAccountId $storageaccountid -TimeLimitInSeconds $packetCaptureDuration
        Out-File -Encoding Ascii -FilePath $res -inputObject "Packet Capture created on ${requestBody.context.resourceID}"
    }
} 
``` 

创建函数后，请将警报配置为调用与该函数相关联的 URL。 若要获取此值，请从 Function App 中复制函数 URL。

![查找函数 URL 1][functions13]

复制 Function App 的函数 URL。

![查找函数 URL 2][2]

如果需要在 webhook POST 请求的有效负载中使用自定义属性，请参阅[针对 Azure 指标警报配置 webhook](../monitoring-and-diagnostics/insights-webhooks-alerts.md)

## <a name="configure-an-alert-on-a-vm"></a>在 VM 上配置警报

可以配置警报，以便在特定的指标超过分配的阈值时通知相关人员。 在本示例中，警报是针对 TCP 段发送的，但也可以从其他许多指标触发该警报。 在本示例中，已将某个警报配置为调用 Webhook 来调用函数。

### <a name="create-the-alert-rule"></a>创建警报规则

导航到现有虚拟机并添加警报规则。 有关配置警报的更详细文档，请参阅[在 Azure Monitor 中为 Azure 服务创建警报 - Azure 门户](../monitoring-and-diagnostics/insights-alerts-portal.md)。 在边栏选项卡中输入以下值，然后单击“确定”

  |**设置** | **值** | **详细信息** |
  |---|---|---|
  |**Name**|TCP_Segments_Sent_Exceeded|警报规则的名称。|
  |**说明**|发送的 TCP 段已超出阈值|警报规则的说明。||
  |**指标**|发送的 TCP 段| 用于触发警报的指标。 |
  |**条件**|大于| 评估指标时要使用的条件。|
  |**阈值**|100| 这是要触发警报的指标的值，应将此值设置为环境的有效值。|
  |**时间段**|过去 5 分钟| 确定要在其中查找指标阈值的时间段。|
  |**Webhook**|[Function App 中的 Webhook URL]| 这是前面的步骤创建的 Function App 的 Webhook URL。|

> [!NOTE]
> 默认情况下不启用 TCP 段计量。 请访问[启用监视和诊断](../monitoring-and-diagnostics/insights-how-to-use-diagnostics.md)，详细了解如何启用其他指标

## <a name="review-the-results"></a>查看结果

在警报触发器条件的后面，将创建一个数据包捕获。 导航到网络观察程序并单击“数据包捕获”。 从此页面中，可以单击数据包捕获文件链接下载数据包捕获

![查看数据包捕获][functions14]

如果捕获文件存储在本地，可以通过登录到虚拟机来检索捕获文件。

有关从 Azure 存储帐户下载文件的说明，请参阅[通过 .NET 开始使用 Azure Blob 存储](../storage/storage-dotnet-how-to-use-blobs.md)。 另一个可以使用的工具是存储资源管理器。 有关存储资源管理器的详细信息可以在此链接中找到：[存储资源管理器](http://storageexplorer.com/)。

下载捕获后，可以使用能够读取 **.cap** 文件的任何工具来查看捕获。 下面提供了其中两个工具的链接：

- [Microsoft Message Analyzer](https://technet.microsoft.com/library/jj649776.aspx)
- [WireShark](https://www.wireshark.org/)

## <a name="next-steps"></a>后续步骤

访问[使用 Wireshark 分析数据包捕获](network-watcher-alert-triggered-packet-capture.md)，了解如何查看数据包捕获

[1]: ./media/network-watcher-alert-triggered-packet-capture/figure1.png
[1-1]: ./media/network-watcher-alert-triggered-packet-capture/figure1-1.png
[2]: ./media/network-watcher-alert-triggered-packet-capture/figure2.png
[3]: ./media/network-watcher-alert-triggered-packet-capture/figure3.png
[functions1]:./media/network-watcher-alert-triggered-packet-capture/functions1.png
[functions2]:./media/network-watcher-alert-triggered-packet-capture/functions2.png
[functions3]:./media/network-watcher-alert-triggered-packet-capture/functions3.png
[functions4]:./media/network-watcher-alert-triggered-packet-capture/functions4.png
[functions5]:./media/network-watcher-alert-triggered-packet-capture/functions5.png
[functions6]:./media/network-watcher-alert-triggered-packet-capture/functions6.png
[functions7]:./media/network-watcher-alert-triggered-packet-capture/functions7.png
[functions8]:./media/network-watcher-alert-triggered-packet-capture/functions8.png
[functions9]:./media/network-watcher-alert-triggered-packet-capture/functions9.png
[functions10]:./media/network-watcher-alert-triggered-packet-capture/functions10.png
[functions11]:./media/network-watcher-alert-triggered-packet-capture/functions11.png
[functions12]:./media/network-watcher-alert-triggered-packet-capture/functions12.png
[functions13]:./media/network-watcher-alert-triggered-packet-capture/functions13.png
[functions14]:./media/network-watcher-alert-triggered-packet-capture/functions14.png
[scenario]:./media/network-watcher-alert-triggered-packet-capture/scenario.png

