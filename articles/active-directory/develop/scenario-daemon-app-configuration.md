---
title: 配置用于调用 web Api 的守护程序应用-Microsoft 标识平台 |Microsoft
description: 了解如何为后台应用程序配置调用 web Api 的代码（应用配置）
services: active-directory
documentationcenter: dev-center-name
author: jmprieur
manager: CelesteDG
editor: ''
ms.service: active-directory
ms.subservice: develop
ms.devlang: na
ms.topic: conceptual
ms.tgt_pltfrm: na
ms.workload: identity
ms.date: 10/30/2019
ms.author: jmprieur
ms.custom: aaddev
ms.openlocfilehash: 88062c2134600d5b1460858c3799cfc8daa83744
ms.sourcegitcommit: 984c5b53851be35c7c3148dcd4dfd2a93cebe49f
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/28/2020
ms.locfileid: "76775233"
---
# <a name="daemon-app-that-calls-web-apis---code-configuration"></a>用于调用 web Api 的后台应用程序-代码配置

了解如何为后台应用程序配置调用 web Api 的代码。

## <a name="msal-libraries-that-support-daemon-apps"></a>支持后台应用程序的 MSAL 库

这些 Microsoft 库支持后台程序应用：

  MSAL 库 | Description
  ------------ | ----------
  ![MSAL.NET](media/sample-v2-code/logo_NET.png) <br/> MSAL.NET  | 支持 .NET Framework 和 .NET Core 平台，以生成后台应用程序。 （UWP、Xamarin 和 Xamarin 不受支持，因为这些平台用于构建公用客户端应用程序。）
  ![Python](media/sample-v2-code/logo_python.png) <br/> MSAL Python | Python 中的后台应用程序支持。
  ![Java](media/sample-v2-code/logo_java.png) <br/> MSAL Java | 对 Java 中的后台应用程序的支持。

## <a name="configure-the-authority"></a>配置证书颁发机构

后台应用程序使用应用程序权限，而不是委托的权限。 因此，其支持的帐户类型不能是任何组织目录或任何个人 Microsoft 帐户（例如 Skype、Xbox、Outlook.com）中的帐户。 无租户管理员可以向 Microsoft 个人帐户的后台应用程序授予许可。 你需要选择组织中的*帐户*或*任何组织中的帐户*。

因此，应用程序配置中指定的颁发机构应为租户（指定租户 ID 或与组织关联的域名）。

如果你是 ISV 并想要提供多租户工具，则可以使用 `organizations`。 但请记住，你还需要向客户说明如何授予管理员同意。 有关详细信息，请参阅[请求整个租户的同意](v2-permissions-and-consent.md#requesting-consent-for-an-entire-tenant)。 此外，当前 MSAL 中有一个限制：只有当客户端凭据是应用程序机密（而不是证书）时，才允许 `organizations`。

## <a name="configure-and-instantiate-the-application"></a>配置并实例化应用程序

在 MSAL 库中，客户端凭据（机密或证书）作为机密客户端应用程序构造的参数进行传递。

> [!IMPORTANT]
> 即使您的应用程序是作为一种服务运行的控制台应用程序，如果该应用程序是后台应用程序，则它需要是机密的客户端应用程序。

### <a name="configuration-file"></a>配置文件

配置文件定义：

- 颁发机构、云实例和租户 ID。
- 从应用程序注册获得的客户端 ID。
- 客户端机密或证书。

# <a name="nettabdotnet"></a>[.NET](#tab/dotnet)

[.Net Core 控制台后台](https://github.com/Azure-Samples/active-directory-dotnetcore-daemon-v2)程序示例中的[appsettings](https://github.com/Azure-Samples/active-directory-dotnetcore-daemon-v2/blob/master/1-Call-MSGraph/daemon-console/appsettings.json) 。

```JSon
{
  "Instance": "https://login.microsoftonline.com/{0}",
  "Tenant": "[Enter here the tenantID or domain name for your Azure AD tenant]",
  "ClientId": "[Enter here the ClientId for your application]",
  "ClientSecret": "[Enter here a client secret for your application]",
  "CertificateName": "[Or instead of client secret: Enter here the name of a certificate (from the user cert store) as registered with your application]"
}
```

提供 `ClientSecret` 或 `CertificateName`。 这些设置是专用的。

# <a name="pythontabpython"></a>[Python](#tab/python)

当你使用客户端机密构建机密客户端时， [Python daemon](https://github.com/Azure-Samples/ms-identity-python-daemon)示例中的[参数 json](https://github.com/Azure-Samples/ms-identity-python-daemon/blob/master/1-Call-MsGraph-WithSecret/parameters.json)配置文件如下所示：

```Json
{
  "authority": "https://login.microsoftonline.com/Enter_the_Tenant_Name_Here",
  "client_id": "your_client_id",
  "scope": [ "https://graph.microsoft.com/.default" ],
  "secret": "The secret generated by AAD during your confidential app registration",
  "endpoint": "https://graph.microsoft.com/v1.0/users"
}
```

当你使用证书生成机密客户端时， [Python daemon](https://github.com/Azure-Samples/ms-identity-python-daemon)示例中的[参数 json](https://github.com/Azure-Samples/ms-identity-python-daemon/blob/master/2-Call-MsGraph-WithCertificate/parameters.json)配置文件如下所示：

```Json
{
  "authority": "https://login.microsoftonline.com/Enter_the_Tenant_Name_Here",
  "client_id": "your_client_id",
  "scope": [ "https://graph.microsoft.com/.default" ],
  "thumbprint": "790E... The thumbprint generated by AAD when you upload your public cert",
  "private_key_file": "server.pem",
  "endpoint": "https://graph.microsoft.com/v1.0/users"
}
```

# <a name="javatabjava"></a>[Java](#tab/java)

[TestData](https://github.com/AzureAD/microsoft-authentication-library-for-java/blob/dev/src/samples/public-client/TestData.java)是用于配置 MSAL Java 开发人员示例的类：

```Java
public class TestData {

    final static String TENANT_SPECIFIC_AUTHORITY = "https://login.microsoftonline.com/<TenantId>/";
    final static String GRAPH_DEFAULT_SCOPE = "https://graph.microsoft.com/.default";
    final static String CONFIDENTIAL_CLIENT_ID = "";
    final static String CONFIDENTIAL_CLIENT_SECRET = "";
}
```

---

### <a name="instantiate-the-msal-application"></a>实例化 MSAL 应用程序

若要实例化 MSAL 应用程序，需要添加、引用或导入 MSAL 包（具体取决于语言）。

构造是不同的，具体取决于你使用的是客户端机密还是证书（或作为高级方案，有符号断言）。

#### <a name="reference-the-package"></a>引用包

在应用程序代码中引用 MSAL 包。

# <a name="nettabdotnet"></a>[.NET](#tab/dotnet)

将[IdentityClient](https://www.nuget.org/packages/Microsoft.Identity.Client) NuGet 包添加到应用程序。
在 MSAL.NET 中，机密客户端应用程序由 `IConfidentialClientApplication` 接口表示。
在源代码中使用 MSAL.NET 命名空间。

```csharp
using Microsoft.Identity.Client;
IConfidentialClientApplication app;
```

# <a name="pythontabpython"></a>[Python](#tab/python)

```python
import msal
```

# <a name="javatabjava"></a>[Java](#tab/java)

```java
import com.microsoft.aad.msal4j.ClientCredentialFactory;
import com.microsoft.aad.msal4j.ClientCredentialParameters;
import com.microsoft.aad.msal4j.ConfidentialClientApplication;
import com.microsoft.aad.msal4j.IAuthenticationResult;
```

---

#### <a name="instantiate-the-confidential-client-application-with-a-client-secret"></a>使用客户端机密实例化机密客户端应用程序

下面是使用客户端机密实例化机密客户端应用程序的代码：

# <a name="nettabdotnet"></a>[.NET](#tab/dotnet)

```csharp
app = ConfidentialClientApplicationBuilder.Create(config.ClientId)
           .WithClientSecret(config.ClientSecret)
           .WithAuthority(new Uri(config.Authority))
           .Build();
```

# <a name="pythontabpython"></a>[Python](#tab/python)

```Python
config = json.load(open(sys.argv[1]))

# Create a preferably long-lived app instance that maintains a token cache.
app = msal.ConfidentialClientApplication(
    config["client_id"], authority=config["authority"],
    client_credential=config["secret"],
    # token_cache=...  # Default cache is in memory only.
                       # You can learn how to use SerializableTokenCache from
                       # https://msal-python.rtfd.io/en/latest/#msal.SerializableTokenCache
    )
```

# <a name="javatabjava"></a>[Java](#tab/java)

```Java
ConfidentialClientApplication app = ConfidentialClientApplication.builder(
        TestData.CONFIDENTIAL_CLIENT_ID,
        ClientCredentialFactory.create(TestData.CONFIDENTIAL_CLIENT_SECRET))
        .authority(TestData.TENANT_SPECIFIC_AUTHORITY)
        .build();
```

---

#### <a name="instantiate-the-confidential-client-application-with-a-client-certificate"></a>使用客户端证书实例化机密客户端应用程序

下面是用证书构建应用程序的代码：

# <a name="nettabdotnet"></a>[.NET](#tab/dotnet)

```csharp
X509Certificate2 certificate = ReadCertificate(config.CertificateName);
app = ConfidentialClientApplicationBuilder.Create(config.ClientId)
    .WithCertificate(certificate)
    .WithAuthority(new Uri(config.Authority))
    .Build();
```

# <a name="pythontabpython"></a>[Python](#tab/python)

```Python
config = json.load(open(sys.argv[1]))

# Create a preferably long-lived app instance that maintains a token cache.
app = msal.ConfidentialClientApplication(
    config["client_id"], authority=config["authority"],
    client_credential={"thumbprint": config["thumbprint"], "private_key": open(config['private_key_file']).read()},
    # token_cache=...  # Default cache is in memory only.
                       # You can learn how to use SerializableTokenCache from
                       # https://msal-python.rtfd.io/en/latest/#msal.SerializableTokenCache
    )
```

# <a name="javatabjava"></a>[Java](#tab/java)

在 MSAL Java 中，有两个生成器用于实例化带有证书的机密客户端应用程序：

```Java

InputStream pkcs12Certificate = ... ; /* Containing PCKS12-formatted certificate*/
string certificatePassword = ... ;    /* Contains the password to access the certificate */

ConfidentialClientApplication app = ConfidentialClientApplication.builder(
        TestData.CONFIDENTIAL_CLIENT_ID,
        ClientCredentialFactory.create(pkcs12Certificate, certificatePassword))
        .authority(TestData.TENANT_SPECIFIC_AUTHORITY)
        .build();
```

或

```Java
PrivateKey key = getPrivateKey(); /* RSA private key to sign the assertion */
X509Certificate publicCertificate = getPublicCertificate(); /* x509 public certificate used as a thumbprint */

ConfidentialClientApplication app = ConfidentialClientApplication.builder(
        TestData.CONFIDENTIAL_CLIENT_ID,
        ClientCredentialFactory.create(rsaPrivateKey, publicKeyCertificate))
        .authority(TestData.TENANT_SPECIFIC_AUTHORITY)
        .build();
```

---

#### <a name="advanced-scenario-instantiate-the-confidential-client-application-with-client-assertions"></a>高级方案：实例化包含客户端断言的机密客户端应用程序

# <a name="nettabdotnet"></a>[.NET](#tab/dotnet)

机密客户端应用程序还可以使用客户端断言来证明其身份，而不是客户端机密或证书。

MSAL.NET 提供了两种方法来向机密客户端应用提供签名断言：

- `.WithClientAssertion()`
- `.WithClientClaims()`

使用 `WithClientAssertion`时，需要提供已签名的 JWT。 此高级方案在[客户端断言](msal-net-client-assertions.md)中详细说明。

```csharp
string signedClientAssertion = ComputeAssertion();
app = ConfidentialClientApplicationBuilder.Create(config.ClientId)
                                          .WithClientAssertion(signedClientAssertion)
                                          .Build();
```

当你使用 `WithClientClaims`时，MSAL.NET 将生成一个有符号的断言，其中包含 Azure AD 所需的声明，以及要发送的附加客户端声明。
此代码演示如何执行此操作：

```csharp
string ipAddress = "192.168.1.2";
var claims = new Dictionary<string, string> { { "client_ip", ipAddress } };
X509Certificate2 certificate = ReadCertificate(config.CertificateName);
app = ConfidentialClientApplicationBuilder.Create(config.ClientId)
                                          .WithAuthority(new Uri(config.Authority))
                                          .WithClientClaims(certificate, claims)
                                          .Build();```
```

同样，有关详细信息，请参阅[客户端断言](msal-net-client-assertions.md)。

# <a name="pythontabpython"></a>[Python](#tab/python)

在 MSAL Python 中，可以通过使用将由此 `ConfidentialClientApplication`的私钥签名的声明来提供客户端声明。

```Python
config = json.load(open(sys.argv[1]))

# Create a preferably long-lived app instance that maintains a token cache.
app = msal.ConfidentialClientApplication(
    config["client_id"], authority=config["authority"],
    client_credential={"thumbprint": config["thumbprint"], "private_key": open(config['private_key_file']).read()},
    client_claims = {"client_ip": "x.x.x.x"}
    # token_cache=...  # Default cache is in memory only.
                       # You can learn how to use SerializableTokenCache from
                       # https://msal-python.rtfd.io/en/latest/#msal.SerializableTokenCache
    )
```

有关详细信息，请参阅[ConfidentialClientApplication](https://msal-python.readthedocs.io/en/latest/#msal.ClientApplication.__init__)的 MSAL Python 参考文档。

# <a name="javatabjava"></a>[Java](#tab/java)

MSAL Java 采用公共预览。 尚不支持已签名的断言。

---

## <a name="next-steps"></a>后续步骤

# <a name="nettabdotnet"></a>[.NET](#tab/dotnet)

> [!div class="nextstepaction"]
> [后台应用程序-正在获取应用程序的令牌](https://docs.microsoft.com/azure/active-directory/develop/scenario-daemon-acquire-token?tabs=dotnet)

# <a name="pythontabpython"></a>[Python](#tab/python)

> [!div class="nextstepaction"]
> [后台应用程序-正在获取应用程序的令牌](https://docs.microsoft.com/azure/active-directory/develop/scenario-daemon-acquire-token?tabs=python)

# <a name="javatabjava"></a>[Java](#tab/java)

> [!div class="nextstepaction"]
> [后台应用程序-正在获取应用程序的令牌](https://docs.microsoft.com/azure/active-directory/develop/scenario-daemon-acquire-token?tabs=java)

---
